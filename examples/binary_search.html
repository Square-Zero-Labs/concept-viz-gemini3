<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binary Search Visualization</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #0f172a;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: white;
    }
    #viz-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    /* Floating Controls Panel - Top Right */
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 260px;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
      z-index: 100;
      transition: opacity 0.3s ease;
    }
    .control-group {
      margin-bottom: 16px;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    label {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #94a3b8;
      margin-bottom: 8px;
    }
    span.value {
      color: #22d3ee;
      font-weight: 600;
    }
    /* Custom Buttons */
    button {
      background: rgba(34, 211, 238, 0.1);
      color: #22d3ee;
      border: 1px solid rgba(34, 211, 238, 0.3);
      padding: 10px 16px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      width: 100%;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    button:hover {
      background: rgba(34, 211, 238, 0.2);
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.2);
      transform: translateY(-1px);
    }
    button:active {
      transform: translateY(0);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    button.secondary {
      background: transparent;
      color: #94a3b8;
      border: 1px solid #334155;
    }
    button.secondary:hover {
      color: #e2e8f0;
      border-color: #64748b;
      background: rgba(255, 255, 255, 0.05);
    }
    /* Custom Sliders */
    input[type=range] {
      width: 100%;
      background: transparent;
      -webkit-appearance: none;
    }
    input[type=range]:focus {
      outline: none;
    }
    input[type=range]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      cursor: pointer;
      background: #334155;
      border-radius: 2px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 14px;
      width: 14px;
      border-radius: 50%;
      background: #c084fc;
      cursor: pointer;
      margin-top: -5px;
      box-shadow: 0 0 10px rgba(192, 132, 252, 0.5);
      transition: transform 0.1s;
    }
    input[type=range]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    /* Status Text */
    .status-overlay {
      position: absolute;
      top: 12%;
      width: 100%;
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }
    .main-status {
      font-size: 2rem;
      font-weight: 300;
      color: #facc15;
      text-shadow: 0 0 20px rgba(250, 204, 21, 0.2);
      margin-bottom: 8px;
      min-height: 3rem;
    }
    .sub-status {
      font-size: 1rem;
      color: #94a3b8;
      font-weight: 400;
    }
    /* Tooltip */
    .tooltip {
      position: absolute;
      background: #1e293b;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      border: 1px solid #334155;
    }
  </style>
  <!-- D3.js Library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

  <!-- Visualization Container -->
  <div id="viz-container"></div>
  
  <!-- Status Overlay -->
  <div class="status-overlay">
    <div class="main-status" id="status-text">Binary Search</div>
    <div class="sub-status" id="detail-text">Select a target or randomize to begin</div>
  </div>

  <!-- Controls Panel -->
  <div class="controls">
    <div class="control-group">
      <label>Array Size <span class="value" id="size-display">30</span></label>
      <input type="range" id="size-slider" min="10" max="100" value="30">
    </div>
    
    <div class="control-group">
       <label>Target: <span class="value" id="target-display">?</span></label>
       <button id="btn-random-target">Pick Random Target</button>
    </div>

    <div class="control-group">
      <div style="display: flex; gap: 8px;">
        <button id="btn-step">Step</button>
        <button id="btn-auto" class="secondary">Auto</button>
      </div>
      <button id="btn-reset" class="secondary" style="margin-top: 8px;">Reset Array</button>
    </div>

    <div class="control-group">
        <label>Speed</label>
        <input type="range" id="speed-slider" min="100" max="2000" value="800" style="direction: rtl">
    </div>
  </div>

  <script>
    /**
     * Binary Search Visualization
     * Style: 3Blue1Brown inspired (Dark, Neon Pastels)
     */

    // Configuration
    const colors = {
      bg: '#0f172a',
      default: '#22d3ee',
      activeRange: '#c084fc',
      mid: '#facc15',
      found: '#f472b6',
      discarded: '#334155',
      text: '#ffffff',
      dimText: '#64748b'
    };

    // State
    let dataset = [];
    let target = null;
    let left = 0;
    let right = 0;
    let mid = -1;
    let searchState = 'IDLE'; // IDLE, SEARCHING, FOUND, NOT_FOUND
    let autoPlayInterval = null;
    let animationSpeed = 800;

    // Dimensions
    const margin = { top: 100, right: 50, bottom: 50, left: 50 };
    let width, height;

    // D3 Selection
    const svg = d3.select("#viz-container").append("svg");
    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // Init
    function init() {
      resize();
      generateData(30);
      window.addEventListener('resize', resize);
    }

    function resize() {
      const container = document.getElementById('viz-container');
      width = container.clientWidth - margin.left - margin.right;
      height = container.clientHeight - margin.top - margin.bottom;
      svg.attr("width", container.clientWidth).attr("height", container.clientHeight);
      updateVis();
    }

    function generateData(size) {
      stopAutoPlay();
      // Generate sorted unique integers
      const set = new Set();
      while(set.size < size) set.add(Math.floor(Math.random() * 100) + 1);
      dataset = Array.from(set).sort((a, b) => a - b);
      
      // Reset State
      left = 0;
      right = dataset.length - 1;
      mid = -1;
      target = null;
      searchState = 'IDLE';
      
      // UI Update
      document.getElementById('size-display').innerText = size;
      document.getElementById('target-display').innerText = '?';
      setStatus("Binary Search", "Array sorted. Ready to search.");
      
      updateVis();
    }

    function setTarget(val) {
      target = val;
      left = 0;
      right = dataset.length - 1;
      mid = -1;
      searchState = 'SEARCHING';
      document.getElementById('target-display').innerText = val;
      setStatus("Searching...", `Targeting value ${val}`);
      updateVis();
    }

    function step() {
      if (searchState === 'FOUND' || searchState === 'NOT_FOUND') return;
      if (target === null) {
        alert("Please pick a target first.");
        return;
      }

      // Calculate Mid
      const newMid = Math.floor((left + right) / 2);
      mid = newMid;
      updateVis(); // Highlight mid

      // Logic Check Delay for visual comprehension
      setTimeout(() => {
        if (dataset[mid] === target) {
          searchState = 'FOUND';
          setStatus("Found!", `Value ${target} found at index ${mid}`);
          stopAutoPlay();
        } else if (left > right) {
          searchState = 'NOT_FOUND';
          setStatus("Not Found", `Value ${target} is not in the array`);
          stopAutoPlay();
        } else {
          // Prepare for next step
          if (dataset[mid] < target) {
            setStatus("Too Low", `${dataset[mid]} < ${target}, discarding left half`);
            left = mid + 1;
          } else {
             setStatus("Too High", `${dataset[mid]} > ${target}, discarding right half`);
            right = mid - 1;
          }
          
          // Check for immediate not found condition after update
          if (left > right) {
             searchState = 'NOT_FOUND';
             setStatus("Not Found", `Value ${target} is not in the array`);
             stopAutoPlay();
          }
        }
        updateVis();
      }, animationSpeed * 0.5);
    }

    // D3 Rendering Logic
    function updateVis() {
      // Scales
      const xScale = d3.scaleBand()
        .domain(d3.range(dataset.length))
        .range([0, width])
        .padding(0.2);

      const yScale = d3.scaleLinear()
        .domain([0, 100])
        .range([height, 0]);

      // Data Join
      const bars = g.selectAll(".bar")
        .data(dataset, d => d);

      // ENTER
      const barsEnter = bars.enter().append("g")
        .attr("class", "bar")
        .attr("transform", (d, i) => `translate(${xScale(i)}, 0)`);

      barsEnter.append("rect")
        .attr("y", height)
        .attr("height", 0)
        .attr("width", xScale.bandwidth())
        .attr("rx", 4)
        .attr("fill", colors.default);

      barsEnter.append("text")
        .attr("class", "label")
        .attr("y", height + 20)
        .attr("x", xScale.bandwidth() / 2)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("fill", colors.dimText)
        .style("opacity", 0)
        .text(d => d);

      // UPDATE
      const barsUpdate = bars.merge(barsEnter);

      // Transitions
      barsUpdate.transition().duration(animationSpeed * 0.5)
        .attr("transform", (d, i) => `translate(${xScale(i)}, 0)`);

      // Dynamic Styling based on State
      barsUpdate.select("rect")
        .transition().duration(animationSpeed * 0.5)
        .attr("y", d => yScale(d))
        .attr("height", d => height - yScale(d))
        .attr("width", xScale.bandwidth())
        .attr("fill", (d, i) => {
          if (searchState === 'FOUND' && i === mid) return colors.found;
          if (i === mid) return colors.mid;
          if (i >= left && i <= right) return colors.default;
          return colors.discarded;
        })
        .style("opacity", (d, i) => {
          if (i >= left && i <= right) return 1;
          return 0.2;
        })
        .style("filter", (d, i) => {
          if (searchState === 'FOUND' && i === mid) return `drop-shadow(0 0 15px ${colors.found})`;
          if (i === mid) return `drop-shadow(0 0 10px ${colors.mid})`;
          if (i >= left && i <= right) return `drop-shadow(0 0 5px ${colors.default})`;
          return "none";
        });

      // Text Styling
      barsUpdate.select(".label")
        .transition().duration(animationSpeed * 0.5)
        .attr("y", d => yScale(d) - 10)
        .style("opacity", (d, i) => {
             // Only show text for active range or if size is small enough
             if (dataset.length < 40) return 1;
             if (i >= left && i <= right) return 1;
             return 0;
        })
        .attr("fill", (d, i) => {
            if (i === mid) return colors.mid;
            if (i >= left && i <= right) return colors.text;
            return colors.dimText;
        })
        .attr("font-weight", (d, i) => (i === mid || (i >= left && i <= right)) ? "bold" : "normal");
        
      // Highlight Window Brackets (Optional visual cue)
      // Could add lines under the active range, but color coding is cleaner for 3b1b style.

      // EXIT
      bars.exit()
        .transition().duration(animationSpeed * 0.3)
        .attr("transform", "translate(0, 50)")
        .style("opacity", 0)
        .remove();
    }

    function setStatus(main, sub) {
      document.getElementById('status-text').innerText = main;
      document.getElementById('detail-text').innerText = sub;
    }

    // Interaction Handlers
    document.getElementById('size-slider').addEventListener('input', (e) => {
      document.getElementById('size-display').innerText = e.target.value;
    });
    document.getElementById('size-slider').addEventListener('change', (e) => {
      generateData(parseInt(e.target.value));
    });

    document.getElementById('speed-slider').addEventListener('input', (e) => {
      animationSpeed = 2100 - parseInt(e.target.value); // Invert so right is faster
    });

    document.getElementById('btn-random-target').addEventListener('click', () => {
      if (dataset.length === 0) return;
      const randIndex = Math.floor(Math.random() * dataset.length);
      setTarget(dataset[randIndex]);
    });

    document.getElementById('btn-step').addEventListener('click', () => {
      stopAutoPlay();
      step();
    });

    document.getElementById('btn-auto').addEventListener('click', () => {
      if (searchState === 'FOUND' || searchState === 'NOT_FOUND') {
          // If finished, maybe reset target to random if none selected or just restart?
          // For simplicity, if done, pick new random target to demo continuous play
          const randIndex = Math.floor(Math.random() * dataset.length);
          setTarget(dataset[randIndex]);
      }
      if (target === null) {
          const randIndex = Math.floor(Math.random() * dataset.length);
          setTarget(dataset[randIndex]);
      }
      
      if (autoPlayInterval) stopAutoPlay();
      autoPlayInterval = setInterval(step, animationSpeed + 100);
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
        const size = parseInt(document.getElementById('size-slider').value);
        generateData(size);
    });

    function stopAutoPlay() {
      if (autoPlayInterval) {
        clearInterval(autoPlayInterval);
        autoPlayInterval = null;
      }
    }

    // Start
    init();

  </script>
</body>
</html>